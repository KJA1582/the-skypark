using Microsoft.Win32;
using Newtonsoft.Json;
using Org.BouncyCastle.Crypto;
using Org.BouncyCastle.OpenSsl;
using Org.BouncyCastle.Security;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Net.Http;
using System.Security.Cryptography;
using System.Text;
using System.Threading.Tasks;

namespace TSP_Installer
{

    class LicensingInstance
    {
        class OrbxApiError
        {
            public string Message { get; set; }
        }

        class OrbxApiData
        {
            public string Key { get; set; }
        }

        class OrbxApiResponse
        {
            public bool Success { get; set; }
            public OrbxApiError Error { get; set; }
            public OrbxApiData Data { get; set; }
        }

        /// <summary>
        /// Unique Product ID provided by Orbx.
        /// </summary>
        private Guid ProductID { get; set; }

        /// <summary>
        /// Public key for this application provided by Orbx.
        /// </summary>
        private byte[] ApplicationKey { get; set; }

        /// <summary>
        /// The product license key.
        /// </summary>
        private string LicenseKey { get; set; }

        /// <summary>
        /// Unique device ID generated by client.
        /// </summary>
        private string Identifier { get; set; }

        /// <param name="product">Product GUID provided by Orbx.</param>
        /// <param name="appKey">Application public key provided by Orbx.</param>
        public LicensingInstance(Guid appID, byte[] key)
        {
            ProductID = appID;
            ApplicationKey = key;
            Identifier = GetOrbxIdentifier() + GetSystemIdentifier();

            try
            {
                LicenseKey = GetKey();
            }
            catch (Exception)
            {
                throw new FileNotFoundException("Unable to load license key.");
            }
        }

        /// <summary>
        /// Converts hexidecimal string encoding to bytes.
        /// </summary>
        /// <param name="sig"></param>
        /// <returns></returns>
        private byte[] DecodeContent(string sig)
            => (from i in Enumerable.Range(0, sig.Length / 2) select Convert.ToByte(sig.Substring(i * 2, 2), 16)).ToArray();

        /// <summary>
        /// Decodes the application key.
        /// </summary>
        /// <param name="d"></param>
        /// <returns></returns>
        private byte[] GetAppKey(byte[] d)
        {
            byte[] r = d.ToArray();

            for (int i = 0; i < r.Length; i++)
                r[i] = (byte)(r[i] - (i * 2));

            return r;
        }

        /// <summary>
        /// Gets the Orbx generated segment of the system identity.
        /// </summary>
        /// <returns></returns>
        public string GetOrbxIdentifier()
        {
            string path = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), "Orbx", ".lic", ".id");

            return File.ReadAllText(path);
        }

        /// <summary>
        /// Gets the system-based segment of the system identity.
        /// </summary>
        /// <returns></returns>
        public string GetSystemIdentifier()
        {
            return Registry.GetValue("HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Cryptography", "MachineGuid", null).ToString().Replace("-", "");
        }

        /// <summary>
        /// Gets the extra k/v data included in the key.
        /// </summary>
        /// <returns></returns>
        public Dictionary<string, string> GetParameters()
        {
            string[] segments = LicenseKey.Split('$');
            string message = segments[0];
            string opts = message.Split('@')[1];

            string decoded = Encoding.UTF8.GetString(DecodeContent(opts));

            var p = JsonConvert.DeserializeObject<Dictionary<string, string>>(decoded);

            return p;
        }

        /// <summary>
        /// Checks whether the key for this product is valid.
        /// </summary>
        /// <returns></returns>
        public bool IsValid()
        {
            string key = GetKey();

            string[] segments = key.Split('$');
            string message = segments[0];
            string signature = segments[1];
            string[] content = message.Split('@');

            // prepare to verify the signature
            var encoder = new ASCIIEncoding();
            var inputData = encoder.GetBytes(message);
            var signer = SignerUtilities.GetSigner("SHA-256withECDSA");

            // read in the app public key
            PemReader pr = new PemReader(new StringReader(Encoding.ASCII.GetString(GetAppKey(ApplicationKey))));
            AsymmetricKeyParameter publicKey = (AsymmetricKeyParameter)pr.ReadObject();

            signer.Init(false, publicKey);
            signer.BlockUpdate(inputData, 0, inputData.Length);

            // if the signature of the key is invalid, the key has been modified
            if (!signer.VerifySignature(DecodeContent(signature)))
                return false;

            string id = content[0]; // device identifier
            string opts = content[1]; // encoded extra k/v pairs
            int timestamp = Convert.ToInt32(content[2], 16); // when the key expires

            DateTime d = DateTime.UtcNow;
            long t = ((DateTimeOffset)d).ToUnixTimeSeconds();

            // check if the key has expired
            if (t > timestamp)
                return false;

            var data = Encoding.ASCII.GetBytes(Identifier);
            string hash;

            // generate hash of the device identifier
            using (var sha256 = new SHA256Managed())
            {
                hash = string.Join("", sha256.ComputeHash(data).Select(q => q.ToString("X2", CultureInfo.InvariantCulture)));
            }

            // if the identifier is different, we're on a different device than this key is for
            if (hash.ToUpper(CultureInfo.InvariantCulture) != id.ToUpper(CultureInfo.InvariantCulture))
                return false;

            return true;
        }

        /// <summary>
        /// Contacts Orbx and refreshes the license key.
        /// </summary>
        public async Task Refresh()
        {
            using (HttpClient client = new HttpClient())
            {
                var data = new Dictionary<string, string>
                {
                    { "id", Identifier },
                    { "os", "win32" },
                    { "product", ProductID.ToString() },
                    { "key", GetKey() }
                };

                using (var content = new FormUrlEncodedContent(data))
                {
                    var response = await client.PostAsync(new Uri("https://orbxdirect.com/api/v4/licensing/refresh"), content);

                    if (!response.IsSuccessStatusCode)
                        throw new Exception("Unable to refresh key");

                    var resp = JsonConvert.DeserializeObject<OrbxApiResponse>(await response.Content.ReadAsStringAsync());

                    WriteKey(resp.Data.Key);

                    Console.WriteLine(resp.Data.Key);
                }
            }
        }

        /// <summary>
        /// Reads the license key from disk.
        /// </summary>
        /// <returns></returns>
        private string GetKey()
        {
            string path = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), "Orbx", ".lic", ProductID.ToString());

            return File.ReadAllText(path);
        }

        /// <summary>
        /// Writes the given key to disk.
        /// </summary>
        /// <param name="key"></param>
        private void WriteKey(string key)
        {
            string path = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), "Orbx", ".lic", ProductID.ToString());

            File.WriteAllText(path, key);
        }
    }
}
